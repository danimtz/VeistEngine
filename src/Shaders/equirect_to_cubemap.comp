#version 450



layout(local_size_x = 8, local_size_y = 8) in;

layout(set = 0, binding = 0) uniform sampler2D in_envmap;

layout(rgba8, set = 0, binding = 1) uniform writeonly imageCube out_cubemap;
//layout(rgba32f, set = 0, binding = 1) uniform writeonly imageCube out_cubemap;


//Converts uv coordinate in equirectmap to a direction in the corresponding cubemap
vec3 cubemapDirection(vec2 uv, uint face)
{
    const vec2 tex_coord = uv * 2.0 - 1.0; //convert to -1 to 1 range

    if(face == 0) return vec3(1.0, -tex_coord.y, -tex_coord.x); // front
    if(face == 1) return vec3(-1.0, -tex_coord.y, tex_coord.x); // back

    if(face == 2) return vec3(tex_coord.x, 1.0, tex_coord.y); // right
    if(face == 3) return vec3(tex_coord.x, -1.0, -tex_coord.y); // left

    if(face == 4) return vec3(tex_coord.x, -tex_coord.y, 1.0); // top
    if(face == 5) return vec3(-tex_coord.x, -tex_coord.y, -1.0); // bottom



}


//Returns UV coordinates of equirect map that corresponds to that cubemap direction
vec2 sampleSphericalMap(vec3 dir)
{
    const vec2 invAtan = vec2(0.1591, 0.3183);

    vec2 uv = vec2(atan(dir.z, dir.x), asin(dir.y));
    uv *= invAtan;
    uv += 0.5;

    return uv;
}




void main() {
    const vec2 coord = ivec2(gl_GlobalInvocationID.xy);
    const vec2 uv = (gl_GlobalInvocationID.xy + vec2(0.5)) / vec2(imageSize(out_cubemap).xy);

    for(uint i = 0; i < 6; i++) {
        const vec3 cubemap_dir = normalize(cubemapDirection(uv, i));
     
        vec3 conv = texture(in_envmap, sampleSphericalMap(cubemap_dir)).rgb;
       

        imageStore(out_cubemap, ivec3(coord, i), vec4(conv, 0.0));
    }
}